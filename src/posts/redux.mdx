---
title: Redux Cross-Tab State Syncing
description: How I implemented cross-tab & persisted state synchronization in Next.js App Router using Redux Persist and Redux State Sync.
date: 22-06-2024
slug: redux-persist-tab-syncing-on-nextjs
---

**Note: This post was written before wanderer.moe was rebranded to skowt.cc-written content has been updated to reflect these changes.**

While building the mass download feature for [skowt.cc](https://skowt.cc), I needed users to select multiple assets and download them in one click. State had to sync in real-time across browser tabs.

<Video src="https://cdn.marcel.best/ShareX/2024/06/NVIDIA_Share_EcVTfGPyHw.mp4" />

## The Challenge

I needed state that could:

1. Share across the entire application
2. Persist through page refreshes and tab closures
3. Synchronize in real-time across multiple browser tabs

React's Context API handles cross-component state well. It fails at persistence and cross-tab sync.

Solution: Redux, Redux Persist, and Redux State Sync.

### Storage Implementation

First, a storage adapter that handles both client and server rendering:

```typescript
import createWebStorage from "redux-persist/es/storage/createWebStorage";

const createNoopStorage = () => {
    return {
        getItem() {
            return Promise.resolve(null);
        },
        setItem(_key: string, value: number) {
            return Promise.resolve(value);
        },
        removeItem() {
            return Promise.resolve();
        },
    };
};

export const storage =
    typeof window !== "undefined"
        ? createWebStorage("local")
        : createNoopStorage();
```

### Redux State Structure

Two pieces of state:

- `isMassDownloading`: Boolean flag tracking download progress across tabs
- `selectedAssets`: Array of selected assets

```typescript
import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import type { Asset } from "~/lib/types";

export interface IAssetState {
    isMassDownloading: boolean;
    selectedAssets: Asset[];
}

const initialState: IAssetState = {
    isMassDownloading: false,
    selectedAssets: [],
};
```

### Redux Slice Implementation

An `assetSlice` with actions and reducers managing asset selection and download state:

```typescript
export const assetSlice = createSlice({
    name: "assets",
    initialState,
    reducers: {
        setSelectedAssets: (state, action: PayloadAction<Asset[]>) => {
            state.selectedAssets = action.payload || [];
        },
        setIsMassDownloading: (state, action: PayloadAction<boolean>) => {
            state.isMassDownloading = action.payload || false;
        },
        toggleAssetSelection: (state, action: PayloadAction<Asset>) => {
            if (state.isMassDownloading) return;

            const index = state.selectedAssets.findIndex(
                (asset) => asset.path === action.payload.path,
            );
            if (index >= 0) {
                state.selectedAssets.splice(index, 1);
            } else {
                state.selectedAssets.push(action.payload);
            }
        },
        clearSelectedAssets: (state) => {
            state.selectedAssets = [];
        },
    },
});
```

### Redux Configuration

`persistReducer` and `combineReducers` persist state across sessions:

```typescript
import { combineReducers } from "@reduxjs/toolkit";
import { persistReducer } from "redux-persist";
import { storage } from "./storage";
import assetSlice from "./slice/asset-slice";

export const persistConfig = {
    key: "root",
    storage: storage,
    whitelist: ["assets"],
};

const rootReducer = combineReducers({
    assets: assetSlice,
});

export const persistedReducer = persistReducer(persistConfig, rootReducer);
```

The Redux store uses `createStateSyncMiddleware` and `initMessageListener` to synchronize state across tabs:

```typescript
import { configureStore } from "@reduxjs/toolkit";
import { persistedReducer } from "./reducer";
import {
    createStateSyncMiddleware,
    initMessageListener,
} from "redux-state-sync";
import {
    useDispatch,
    TypedUseSelectorHook,
    useSelector,
    useStore,
} from "react-redux";
import logger from "redux-logger";
import { persistStore } from "redux-persist";

const blacklist = ["persist/PERSIST", "persist/REHYDRATE"];

export const store = configureStore({
    reducer: persistedReducer,
    middleware: (getDefaultMiddleware) =>
        getDefaultMiddleware().prepend(
            logger,
            createStateSyncMiddleware({
                predicate: (action) => {
                    if (typeof action !== "function") {
                        if (Array.isArray(blacklist)) {
                            return blacklist.indexOf(action.type) < 0;
                        }
                    }
                    return false;
                },
            }),
        ) as any, // typescript complains
});

export const persistor = persistStore(store);

initMessageListener(store);
```

### Redux Provider

Wrap the application with `Provider` and `PersistGate`:

```tsx
"use client";

import { Provider } from "react-redux";
import { PersistGate } from "redux-persist/integration/react";
import { store, persistor } from "./store";

export const ReduxProvider = ({ children }: { children: React.ReactNode }) => {
    return (
        <Provider store={store}>
            <PersistGate loading={null} persistor={persistor}>
                {children}
            </PersistGate>
        </Provider>
    );
};

export default ReduxProvider;
```

## Component Integration

Access state and dispatch actions from any component:

```tsx
import { useAppDispatch, useAppSelector } from "~/redux/store";

const dispatch = useAppDispatch();

const isSelected = isAssetSelected(
    useAppSelector((state) => state.assets),
    asset,
);
```

Dispatching actions is straightforward:

```ts
<button onClick={() => dispatch(toggleAssetSelection(asset))}>
    {isSelected ? "Deselect" : "Select"}
</button>
```

### Download Indicator

A local context manages the download indicator state, comparing it with global Redux state to determine what to render:

```tsx
const {
    isUnsharedMassDownloading,
    setIsUnsharedMassDownloading,
    isIndicatorOpen,
} = useContext(AssetDownloadIndicatorContext);

const isMassDownloading = useAppSelector(
    (state) => state.assets.isMassDownloading,
);


{isUnsharedMassDownloading ? (
    <ShowMassDownloadProgress />
) : null}

{isMassDownloading && !isUnsharedMassDownloading ? (
    <MassDownloadInProgress />
) : null}

```

## Conclusion

Cross-tab state synchronization improved engagement on skowt.cc. Users appreciate continuity when switching between tabs, and it encourages them to revisit the site.

View the full source code on [GitHub](https://github.com/skowtcc/site) or try it yourself on [skowt.cc](https://skowt.cc).
