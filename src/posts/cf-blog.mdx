---
title: Posts in Next.js on Cloudflare Pages
description: How I added posts to my Next.js App Router site hosted on Cloudflare Pages.
date: 12-06-2024
slug: cf-pages-nextjs-blog
---

I rewrote my site in [Next.js](https://nextjs.org), hosting on [Cloudflare Pages](https://pages.cloudflare.com/) via [next-on-pages](https://github.com/cloudflare/next-on-pages/).

Next-on-pages works well, but the setup isn't obvious if you're unfamiliar with Cloudflare's deployment model. Here's how I implemented a blog system.

## MDX Support

I chose `next-mdx-remote` for its clean API and React component rendering.

Create `mdx.d.ts` in your project root:

```ts
declare module "*.mdx" {
    let MDXComponent: (props) => JSX.Element;
    export default MDXComponent;
}
```

Configure `next.config.js` for static export (required for Cloudflare Pages):

```ts
const nextConfig = {
    /// ....
    output: "export",
};
```

## Fetching Posts

I created `fetch-posts.ts` with two functions: fetch all posts, fetch by slug.

Read the posts directory with Node's `fs` module, filter for `.mdx` files, skip unpublished posts:

```ts
import matter from "gray-matter";
import fs from "fs/promises";
import path from "path";
import type { Post } from "../types";

export const getPosts = async () => {
    const posts = await fs.readdir("./src/posts/");

    return Promise.all(
        posts
            .filter((file) => path.extname(file) === ".mdx")
            .map(async (file) => {
                const filePath = `./src/posts/${file}`;

                const postContent = await fs.readFile(filePath, "utf8");

                const { data, content } = matter(postContent);

                if (data.published === false) {
                    return null;
                }

                return {
                    title: data.title,
                    slug: data.slug,
                    date: data.date,
                    description: data.description,
                    views: data.views || null,
                    body: content,
                } as Post;
            }),
    );
};
```

Single post fetch leverages `getPosts`:

```ts
export async function getPost(slug: string) {
    const posts = await getPosts();
    return posts.find((post) => post?.slug === slug);
}
```

## Rendering

Custom components for markdown elements live in `markdown-component.tsx`:

```tsx
function Strong(
    props: React.DetailedHTMLProps<
        React.HTMLAttributes<HTMLElement>,
        HTMLElement
    >,
) {
    const { children, ...rest } = props;
    return (
        <b {...rest} className="text-foreground font-semibold">
            {children}
        </b>
    );
}


export const mdxComponents: MDXComponents = {
    strong: Strong,
};
```

The `post-body.tsx` component renders markdown with remark and rehype plugins:

```tsx
import { MDXRemote } from "next-mdx-remote/rsc";

import remarkGfm from "remark-gfm";
import rehypeSlug from "rehype-slug";
import rehypeAutolinkHeadings from "rehype-autolink-headings";
import remarkA11yEmoji from "@fec/remark-a11y-emoji";
import remarkToc from "remark-toc";
import { mdxComponents } from "./markdown-component";

export function PostBody({ children }: { children: string }) {
    return (
        <MDXRemote
            source={children}
            options={{
                mdxOptions: {
                    remarkPlugins: [remarkGfm, remarkA11yEmoji, remarkToc],
                    rehypePlugins: [rehypeSlug, rehypeAutolinkHeadings],
                },
            }}
            components={mdxComponents}
        />
    );
}
```

Pass the post body to `PostBody` to render. For `posts/[id]`, pre-generate routes with `generateStaticParams` (edge rendering isn't supported):

```ts
export async function generateStaticParams() {
    const posts = await getPosts();

    return posts.map((post) => ({
        id: post!.slug,
    }));
}
```

Generate metadata:

```ts
export async function generateMetadata({ params }: Props): Promise<Metadata> {
    const { id } = params;
    const post = await getPost(id);

    if (!post) return notFound();

    return {
        title: `${post.title} â€¢ dromzeh.dev`,
        description: post.description,
        metadataBase: new URL("https://dromzeh.dev"),
    };
}
```

Fetch and render in the PostPage component:

```tsx
export default async function PostPage({ params: { id } }: Props) {
    const post = await getPost(id);

    if (!post) return notFound();

    return (
        <div className="min-h-screen max-w-xl mx-auto flex items-center justify-center">
                <section className="flex flex-col space-y-4 mt-8 max-w-xl">
                    <PostBody>{post.body}</PostBody>
                </section>
            </div>
        </div>
    );
}
```

## Extending

This foundation supports tags, categories, search, or any other features you need.

Full source on [GitHub](https://git.dromzeh.dev/dromzeh.dev).
